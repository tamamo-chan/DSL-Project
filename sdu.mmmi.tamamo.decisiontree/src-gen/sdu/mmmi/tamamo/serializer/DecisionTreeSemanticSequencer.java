/*
 * generated by Xtext 2.24.0
 */
package sdu.mmmi.tamamo.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sdu.mmmi.tamamo.decisionTree.Conclusion;
import sdu.mmmi.tamamo.decisionTree.ConclusionNested;
import sdu.mmmi.tamamo.decisionTree.Decision;
import sdu.mmmi.tamamo.decisionTree.DecisionTreePackage;
import sdu.mmmi.tamamo.decisionTree.GreaterEqual;
import sdu.mmmi.tamamo.decisionTree.GreaterThan;
import sdu.mmmi.tamamo.decisionTree.Input;
import sdu.mmmi.tamamo.decisionTree.InputBool;
import sdu.mmmi.tamamo.decisionTree.InputInt;
import sdu.mmmi.tamamo.decisionTree.InputString;
import sdu.mmmi.tamamo.decisionTree.LessEqual;
import sdu.mmmi.tamamo.decisionTree.LessThan;
import sdu.mmmi.tamamo.decisionTree.Rules;
import sdu.mmmi.tamamo.decisionTree.Start;
import sdu.mmmi.tamamo.services.DecisionTreeGrammarAccess;

@SuppressWarnings("all")
public class DecisionTreeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DecisionTreeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DecisionTreePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DecisionTreePackage.CONCLUSION:
				sequence_Conclusion(context, (Conclusion) semanticObject); 
				return; 
			case DecisionTreePackage.CONCLUSION_NESTED:
				if (rule == grammarAccess.getConclusionNestedRule()) {
					sequence_ConclusionNested(context, (ConclusionNested) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConclusionRule()) {
					sequence_Conclusion_ConclusionNested(context, (ConclusionNested) semanticObject); 
					return; 
				}
				else break;
			case DecisionTreePackage.DECISION:
				sequence_Decision(context, (Decision) semanticObject); 
				return; 
			case DecisionTreePackage.GREATER_EQUAL:
				sequence_Operator(context, (GreaterEqual) semanticObject); 
				return; 
			case DecisionTreePackage.GREATER_THAN:
				sequence_Operator(context, (GreaterThan) semanticObject); 
				return; 
			case DecisionTreePackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case DecisionTreePackage.INPUT_BOOL:
				sequence_InputBool(context, (InputBool) semanticObject); 
				return; 
			case DecisionTreePackage.INPUT_INT:
				sequence_InputInt(context, (InputInt) semanticObject); 
				return; 
			case DecisionTreePackage.INPUT_STRING:
				sequence_InputString(context, (InputString) semanticObject); 
				return; 
			case DecisionTreePackage.LESS_EQUAL:
				sequence_Operator(context, (LessEqual) semanticObject); 
				return; 
			case DecisionTreePackage.LESS_THAN:
				sequence_Operator(context, (LessThan) semanticObject); 
				return; 
			case DecisionTreePackage.PARAMETER:
				sequence_Parameter(context, (sdu.mmmi.tamamo.decisionTree.Parameter) semanticObject); 
				return; 
			case DecisionTreePackage.RULES:
				sequence_Rules(context, (Rules) semanticObject); 
				return; 
			case DecisionTreePackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ConclusionNested returns ConclusionNested
	 *
	 * Constraint:
	 *     (parent=ID nested=Conclusion)
	 */
	protected void sequence_ConclusionNested(ISerializationContext context, ConclusionNested semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.CONCLUSION_NESTED__PARENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.CONCLUSION_NESTED__PARENT));
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.CONCLUSION_NESTED__NESTED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.CONCLUSION_NESTED__NESTED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConclusionNestedAccess().getParentIDTerminalRuleCall_0_0(), semanticObject.getParent());
		feeder.accept(grammarAccess.getConclusionNestedAccess().getNestedConclusionParserRuleCall_2_0(), semanticObject.getNested());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Conclusion returns Conclusion
	 *
	 * Constraint:
	 *     ((left=RuleType operator=Operator right=RuleType decision=Decision next=Conclusion?) | left=ID)
	 */
	protected void sequence_Conclusion(ISerializationContext context, Conclusion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conclusion returns ConclusionNested
	 *
	 * Constraint:
	 *     (parent=ID nested=Conclusion next=Conclusion?)
	 */
	protected void sequence_Conclusion_ConclusionNested(ISerializationContext context, ConclusionNested semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decision returns Decision
	 *
	 * Constraint:
	 *     ((text=ID next=Decision?) | (text=ID nested=Decision next=Decision?))
	 */
	protected void sequence_Decision(ISerializationContext context, Decision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputBool returns InputBool
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InputBool(ISerializationContext context, InputBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.INPUT_BOOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.INPUT_BOOL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputBoolAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputInt returns InputInt
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InputInt(ISerializationContext context, InputInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.INPUT_INT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.INPUT_INT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputIntAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputString returns InputString
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InputString(ISerializationContext context, InputString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.INPUT_STRING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.INPUT_STRING__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputStringAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Input returns Input
	 *
	 * Constraint:
	 *     ((type=InputInt | type=InputString | type=InputBool) next=Input?)
	 */
	protected void sequence_Input(ISerializationContext context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns GreaterEqual
	 *
	 * Constraint:
	 *     {GreaterEqual}
	 */
	protected void sequence_Operator(ISerializationContext context, GreaterEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns GreaterThan
	 *
	 * Constraint:
	 *     {GreaterThan}
	 */
	protected void sequence_Operator(ISerializationContext context, GreaterThan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns LessEqual
	 *
	 * Constraint:
	 *     {LessEqual}
	 */
	protected void sequence_Operator(ISerializationContext context, LessEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operator returns LessThan
	 *
	 * Constraint:
	 *     {LessThan}
	 */
	protected void sequence_Operator(ISerializationContext context, LessThan semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID value=INT next=Parameter?)
	 */
	protected void sequence_Parameter(ISerializationContext context, sdu.mmmi.tamamo.decisionTree.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rules returns Rules
	 *
	 * Constraint:
	 *     (left=RuleType (operator=Operator right=RuleType)? affected_parameter=ID points=INT? next=Rules?)
	 */
	protected void sequence_Rules(ISerializationContext context, Rules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Start returns Start
	 *
	 * Constraint:
	 *     (decision=Decision input=Input parameter=Parameter rules=Rules conclusion=Conclusion)
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.START__DECISION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.START__DECISION));
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.START__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.START__INPUT));
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.START__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.START__PARAMETER));
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.START__RULES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.START__RULES));
			if (transientValues.isValueTransient(semanticObject, DecisionTreePackage.Literals.START__CONCLUSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DecisionTreePackage.Literals.START__CONCLUSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartAccess().getDecisionDecisionParserRuleCall_1_0(), semanticObject.getDecision());
		feeder.accept(grammarAccess.getStartAccess().getInputInputParserRuleCall_3_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getStartAccess().getParameterParameterParserRuleCall_5_0(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getStartAccess().getRulesRulesParserRuleCall_7_0(), semanticObject.getRules());
		feeder.accept(grammarAccess.getStartAccess().getConclusionConclusionParserRuleCall_9_0(), semanticObject.getConclusion());
		feeder.finish();
	}
	
	
}
